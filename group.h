#ifndef ALGEBRA_GROUP_H
#define ALGEBRA_GROUP_H

#include "element.h"
#include "set.h"


// adds all elements from X*Y to s
template<class E>
void direct_product(std::set<E> &s, std::set<E> &nxt, std::set<E> &X, std::set<E> &Y, E &temp) {
    TR(x, X) TR(y, Y) if (!s.count(temp = x.dot(y))) nxt.insert(temp);
}

// templated group class
template<class E>
class group : set<E> {
public:
    // elements in group

    // prints out all elements in group
    friend std::ostream& operator<<(std::ostream& out, const group<E>& g) {
        out << "[";
        for (auto val : g.s) {
            if (val != *g.s.begin()) out << ", ";
            out << val;
        }
        return out << "]";
    }

    // constructor/algorithm to find group generated by {gen}
    template<class C, class T = typename C::value_type> // this template ensures we have a container of type T
    group(C gen) : set<E>(gen) {
        static_assert(std::is_same_v<E, T>, "Wrong type passed to group constructor.");
        if (gen.empty()) return;
        std::set<E> curr{A(*this)}, nxt;
        E temp = *gen.begin();
        while (!curr.empty()) {
            direct_product(*this, nxt, curr, curr, temp);
            direct_product(*this, nxt, curr, *this, temp);
            direct_product(*this, nxt, *this, curr, temp);
            (*this).insert(A(nxt));
            curr = nxt;
            nxt.clear();
        }
    }
};

namespace generate {
    std::set<Int> generators_Z(int n) {
        return {{1, n}};
    }
    group<Int> Z(int n) { return generators_Z(n); }

    std::set<Perm> generators_S(int n) {
        auto rotate_list = vi(n);
        std::iota(A(rotate_list), 2);
        rotate_list[n-1] = 1;
        auto swap_list = vi(n);
        std::iota(A(swap_list), 1);
        std::swap(swap_list[0], swap_list[1]);
        return {rotate_list, swap_list};
    }
    group<Perm> S(int n) { return generators_S(n); }
}


#endif //ALGEBRA_GROUP_H
