#ifndef ALGEBRA_GROUP_H
#define ALGEBRA_GROUP_H

#include "element.h"
#include "set.h"


// templated group class
template<class E>
class group : set<group_element<E>> {
public:
    // composition rule
    std::function<E(E, E)> compose;

    // prints out all elements in group
    friend std::ostream& operator<<(std::ostream& out, const group<E>& g) {
        out << "[";
        for (auto val : g) {
            if (val != *g.begin()) out << ", ";
            out << val;
        }
        return out << "]";
    }

    // constructor/algorithm to find group generated by {gen}
    template<class C, class T = typename C::value_type> // this template ensures we have a container of type T
    group(C gen, std::function<E(E, E)> compose_) {
        static_assert(std::is_same_v<E, T>, "Wrong type passed to group constructor.");
        this->compose = compose_;
        if (gen.empty()) return;
        // https://math.stackexchange.com/questions/1758649/an-algorithm-to-find-a-subgroup-generated-by-a-subset-of-a-finite-group
        std::queue<E> q;
        for (auto &x : gen) q.push(x);
        std::unordered_set<E> H;
        while (q.size()) {
            auto x = q.front();
            q.pop();
            if (H.count(x)) continue;
            H.insert(x);
            for (auto &s : gen) q.push(compose(x, s)), q.push(compose(s, x));
        }
        for (auto &label : H) (*this).insert(group_element<E>(label, &this->compose));
    }
};

namespace generate {
    std::set<ll> generators_Z() { return {1}; }
    std::function<ll(ll, ll)> composition_Z(int n) { return [n](ll a, ll b){ return (a + b) % n; }; }
    group<ll> Z(int n) { return {generators_Z(), composition_Z(n)}; }

//    std::set<Perm> generators_S(int n) {
//        auto rotate_list = vi(n);
//        std::iota(A(rotate_list), 2);
//        rotate_list[n-1] = 1;
//        auto swap_list = vi(n);
//        std::iota(A(swap_list), 1);
//        std::swap(swap_list[0], swap_list[1]);
//        return {rotate_list, swap_list};
//    }
//    group<Perm> S(int n) { return generators_S(n); }
}


#endif //ALGEBRA_GROUP_H
